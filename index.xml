<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mohammad Banisaeid</title>
    <link>https://banisaeid.com/</link>
    <description>Recent content on Mohammad Banisaeid</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Apr 2023 18:03:53 +0200</lastBuildDate><atom:link href="https://banisaeid.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Highlight SQL strings in Rust</title>
      <link>https://banisaeid.com/posts/rust-highlight-sql/</link>
      <pubDate>Mon, 03 Apr 2023 18:03:53 +0200</pubDate>
      
      <guid>https://banisaeid.com/posts/rust-highlight-sql/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>If you are using Neovim with Treesitter, you can use query injections to highlight SQL in Rust strings.</p>
<p>To do so, create a queries folder in your Neovim runtime path:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">mkdir -p ~/.config/nvim/after/queries/rust
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> ~/.config/nvim/after/queries/rust
</span></span></code></pre></div><p>Then create a file called <code>injections.scm</code> in that folder and paste this content there:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scheme" data-lang="scheme"><span class="line"><span class="cl"><span class="c1">; extends</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; A general query injection</span>
</span></span><span class="line"><span class="cl"><span class="c1">; Adapted from </span>
</span></span><span class="line"><span class="cl"><span class="c1">;  https://github.com/ray-x/go.nvim/blob/master/after/queries/go/injections.scm</span>
</span></span><span class="line"><span class="cl"><span class="p">([</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nf">string_literal</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nf">raw_string_literal</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">]</span> <span class="nv">@sql</span>
</span></span><span class="line"><span class="cl"> <span class="p">(</span><span class="o">#</span><span class="nv">match?</span> <span class="nv">@sql</span> <span class="s">&#34;(SELECT|select|INSERT|insert|UPDATE|update|DELETE|delete).+(FROM|from|INTO|into|VALUES|values|SET|set).*(WHERE|where|GROUP BY|group by)?&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">(</span><span class="o">#</span><span class="nv">offset!</span> <span class="nv">@sql</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">-1</span><span class="p">))</span>
</span></span></code></pre></div><p>Restart your Neovim. After opening Rust files with SQL strings, they will have syntax highlighting.</p>
<p>You can see how it looks like in the screenshot below:
<img loading="lazy" src="/rust-sql-highlight.jpg" type="" alt="Screenshot"  /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Improve the Bash startup time</title>
      <link>https://banisaeid.com/posts/improve-bash-startup/</link>
      <pubDate>Mon, 31 Oct 2022 17:18:30 +0100</pubDate>
      
      <guid>https://banisaeid.com/posts/improve-bash-startup/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>I do have a relatively big <a href="https://github.com/smbl64/dotfiles/blob/master/bash/bashrc"><code>bashrc</code></a> file. If you look at that file, you will see this line towards the end:</p>
<pre tabindex="0"><code>test -f ~/.bashrc_local &amp;&amp; source ~/.bashrc_local
</code></pre><p>I use that <code>~/.bashrc_local</code> to keep my personal / work configurations separate.</p>
<p>For quite some time I was bothered by how long it took for Bash to start on my machines. I never measured the actual startup time, but it made me hesitant to open up new terminal windows.</p>
<p>So one day I decided to take care of the slowness.</p>
<p>If you search on the Internet, there aren&rsquo;t that many tools to help with profiling Bash scripts. One trick that I found is to add the following lines around isolated pieces of shell commands and see what they actually do:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">set</span> -v
</span></span><span class="line"><span class="cl"><span class="nb">set</span> -x 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;YOUR COMMANDS&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">set</span> +v
</span></span><span class="line"><span class="cl"><span class="nb">set</span> +x
</span></span></code></pre></div><p>Using this technique, you will get a trace log of what&rsquo;s going on behind the scenes. With some good old trial-and-error, I found these 2 issues in my case:</p>
<ol>
<li>Unnecessary calls to <code>brew</code> to get configuration</li>
<li>Eagerly processing all shell completion files</li>
</ol>
<h2 id="calling-brew-in-your-bashrc">Calling <code>brew</code> in your bashrc</h2>
<p>I love <a href="https://brew.sh/">Homebrew</a>. It is an amazing package manager. However, it is written in Ruby and has a quite slow startup time.</p>
<p>To give you an idea of how slow it can be, I will use <a href="https://github.com/sharkdp/hyperfine">Hyperfine</a> to measure the average time for calling <code>brew --prefix</code>. This <code>brew</code> command gives Homebrew&rsquo;s install path and you can use it to add your installed packages&rsquo; <code>bin</code> directories to <code>$PATH</code>, among other things.</p>
<p>On my machine:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ hyperfine <span class="s1">&#39;brew --prefix&#39;</span>
</span></span><span class="line"><span class="cl">Benchmark 1: brew --prefix
</span></span><span class="line"><span class="cl">  Time <span class="o">(</span>mean ± σ<span class="o">)</span>:      36.7 ms ±   1.1 ms    <span class="o">[</span>User: 14.5 ms, System: 14.7 ms<span class="o">]</span>
</span></span><span class="line"><span class="cl">  Range <span class="o">(</span>min … max<span class="o">)</span>:    35.2 ms …  41.2 ms    <span class="m">72</span> runs
</span></span></code></pre></div><p>That&rsquo;s <code>36 ms</code> just to give us the installation path!</p>
<p>You might think that <code>36 ms</code> is not much, but I had several calls to <code>brew --prefix</code> in my <code>bashrc</code> to get <code>bin</code> paths for <code>coreutils</code>, <code>GNU grep</code>, and other tools. These all add up to hundreds of milliseconds each time the <code>bashrc</code> file is sourced by Bash.</p>
<p><strong>Solution</strong></p>
<p>First, I use <code>brew shellenv</code> to generate environment variables related to Homebrew. One of them is <code>$HOMEBREW_PREFIX</code> which, as you&rsquo;ve probably guessed, gives us the installation path. Now instead of calling <code>brew --prefix</code>, I can use that environment variable.</p>
<p>Even better, I call <code>brew shellenv</code> <em>only once</em> and store the result in a file (<code>$HOME/.brew_env</code>). Then in my <code>bashrc</code> I just <code>source</code> that file and save some more precious milliseconds!</p>
<p>Here is the relevant part in my <a href="https://github.com/smbl64/dotfiles/blob/master/bash/bashrc"><code>bashrc</code></a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">_brew_env_file</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$HOME</span><span class="s2">/.brew_env&#34;</span>
</span></span><span class="line"><span class="cl">__make_brew_envs_file<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># File already exists. Nothing to do.</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> -r <span class="s2">&#34;</span><span class="nv">$HOME</span><span class="s2">/.brew_env&#34;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Creating &#39;</span><span class="nv">$_brew_env_file</span><span class="s2">&#39; file for the first time.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;# Auto-generated by .bashrc script&#34;</span> &gt; <span class="nv">$_brew_env_file</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> &gt;&gt; <span class="nv">$_brew_env_file</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> -x <span class="s2">&#34;</span><span class="k">$(</span><span class="nb">command</span> -v /opt/homebrew/bin/brew<span class="k">)</span><span class="s2">&#34;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        /opt/homebrew/bin/brew shellenv &gt;&gt; <span class="nv">$_brew_env_file</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="o">[[</span> -x <span class="s2">&#34;</span><span class="k">$(</span><span class="nb">command</span> -v /usr/local/bin/brew<span class="k">)</span><span class="s2">&#34;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        /usr/local/bin/brew shellenv &gt;&gt; <span class="nv">$_brew_env_file</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">__make_brew_envs_file
</span></span><span class="line"><span class="cl"><span class="nb">source</span> <span class="nv">$_brew_env_file</span>
</span></span></code></pre></div><h2 id="eagerly-processing-all-shell-completion-files">Eagerly processing all shell completion files</h2>
<p>Before starting my journey in optimizing my <code>bashrc</code>, I suspected that <em>this</em> was the culprit. I wasn&rsquo;t wrong. This was the second source of slowness.</p>
<p>On macOS, I use <a href="https://github.com/scop/bash-completion">Bash Completion</a> package to get shell completion for several commands.</p>
<p>After installing that package, <code>brew</code> tells you to add this line to your Bash startup file:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"> <span class="o">[[</span> -r <span class="s2">&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> 
</span></span><span class="line"><span class="cl">    . <span class="s2">&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span>
</span></span></code></pre></div><p>This works fine. The problem is that whenever you install a package with <code>brew</code>, <code>brew</code> adds the relevant completion files to <code>$HOMEBREW_PREFIX/etc/bash_completion.d/</code> folder. Using the line above, <code>bash-completion</code> package loads all files in the mentioned folder <em>eagerly</em>. This can get <em>very slow</em> if you have installed too many packages.</p>
<p>What we ideally want is to process a completion file <em>on-demand</em>. In other words, when I type <code>tar --</code> and press Tab, I want the relevant completion file to be processed so Bash can give me the completion options. Fortunately <code>bash-completion</code> package supports this out of the box.</p>
<p>To get that, first we need to install the <code>HEAD</code> version of it, because the usual Homebrew version is rather old. To install the <code>HEAD</code> version:</p>
<pre tabindex="0"><code>brew install --HEAD bash-completion@2
</code></pre><p>(I am using Bash 5.x, so I need to use the <code>@2</code> version)</p>
<p>Then, I disable the eager loading of those Homebrew-installed completion files:</p>
<pre tabindex="0"><code>export BASH_COMPLETION_COMPAT_DIR=&#34;/blackhole!&#34;
</code></pre><p><code>/blackhole!</code> can be any non-existing path.</p>
<p>Finally, I ask <code>bash-completion</code> to process Homebrew-installed completion files lazily:</p>
<pre tabindex="0"><code>export BASH_COMPLETION_USER_DIR=&#34;$HOMEBREW_PREFIX/etc/bash-completion:$HOME/.local/share/bash-completion&#34;
</code></pre><p>There are actually two paths specified there. One is for packages that are installed via <code>brew install ...</code>. The other is for my own custom completion files that I put in <code>~/.local/share/bash-completion/</code>.</p>
<blockquote>
<p>The ability to add several folders to <code>BASH_COMPLETION_USER_DIR</code> is added in recent versions of <code>bash-completion@2</code>. That&rsquo;s why I used <code>--HEAD</code> when installing it.</p>
</blockquote>
<p>The full code looks like this:</p>
<pre tabindex="0"><code>__check_bash_completion_symlink() {
    # Create the symlink
    mkdir -p &#34;$HOMEBREW_PREFIX/etc/bash-completion&#34;
    ln -sf &#34;$HOMEBREW_PREFIX/etc/bash_completion.d&#34; &#34;$HOMEBREW_PREFIX/etc/bash-completion/completions&#34;

    # Directories for lazy-loading
    export BASH_COMPLETION_USER_DIR=&#34;$HOMEBREW_PREFIX/etc/bash-completion:$HOME/.local/share/bash-completion&#34;

    # Disable the eagerly-loaded completion scripts
    export BASH_COMPLETION_COMPAT_DIR=&#34;/blackhole!&#34;
}

__check_bash_completion_symlink
[[ -r &#34;$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh&#34; ]] &amp;&amp; 
    . &#34;$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh&#34;
</code></pre><p>On important note: <code>bash-completion</code> expects to find a <code>completions</code> folder inside each folder that&rsquo;s specified in <code>BASH_COMPLETION_USER_DIR</code>. That&rsquo;s the reason for the <code>ln -s</code> trick up there.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
